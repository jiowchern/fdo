// test20110709pm0833.cpp : 定義主控台應用程式的進入點。
//

#include "stdafx.h"
#include <string>
#include <list>

struct Actor;
struct IActorBehavior
{
	virtual	void Injured	(Actor&) = 0;
}

struct Actor : public IActorBehavior
{
			Actor		(const std::string& name , int hp , int pos);
	virtual ~Actor		();
private:
	std::string	_Name;
	int			_Hp;
	int			_Position;
};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
Actor::Actor(const std::string& name , int hp , int pos) :
_Name(name),_Hp(hp),_Position(pos)
{
	
}

Actor::~Actor()
{

}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

struct Monster : public Actor
{
	Monster		(const std::string& name , int hp , int pos);
	~Monster	();
};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
Monster::Monster(const std::string& name , int hp , int pos) : Actor(name, hp ,pos)
{
}

Monster::~Monster()
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

struct Player : public Actor
{
		Player	(const std::string& name , int hp , int pos);
		~Player	();
};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
Player::Player(const std::string& name , int hp , int pos) : Actor(name, hp ,pos)
{
}

Player::~Player()
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename ActorType>
struct ActorSet
{	
			typedef std::list<ActorType> Set;
			Set	_Set;

	void	Admitted	(ActorType&);
};

template<typename ActorType>
void ActorSet<ActorType>::Admitted(ActorType& actor)
{
	_Set.push_back(actor);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

template<typename TActor>	struct Target;
template<>					struct Target<Player>	{typedef Monster Type ;};
template<>					struct Target<Monster>	{typedef Player Type ;};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
struct Zone : 
		protected ActorSet<Monster> 
	,	protected ActorSet<Player>
{
			Zone		();
			~Zone		();

	template<typename TActor>
	void	Admitted	(TActor&);

	template<typename TActor>
	void	Attack		(TActor&,int,int);
private:

	template<>
	void	_QueryActorIterators	();
};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
Zone::Zone()
{
}

Zone::~Zone()
{

}

template<typename TActor>
void Zone::Admitted(TActor& actor)
{
	ActorSet<TActor>::Admitted(actor);
}

template<>
void Zone::_QueryActorIterators(yield)
{	
	ActorSet<TActor>::Set& set = ActorSet<TActor>::_Set;
	ActorSet<TargetType>::Set::iterator itCur = set.begin();
	ActorSet<TargetType>::Set::iterator itEnd	= set.end();

	for( ;itCur != itEnd;++itCur )
	{
		TargetType& target = *itCur;
		yield(target);
	}
}

template<typename TActor>
void Zone::Attack(TActor& atker , int damage , int range)
{
	
	typedef TActor							AttackType ;	
	typedef Target<typename TActor>::Type	TargetType ;		

	
	struct Yield
	{
			Yield	();
			~Yield	();
		void operator() (TargetType& target);
	private:
		AttackType&	_Arker;
	};

	Yield yield(atker);
	_QueryActorIterators(yield);	
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int _tmain(int argc, _TCHAR* argv[])
{
	Player	plrs[] = 
	{
		Player("a" , 100	,5),
		Player("b" , 100	,50),
		Player("c" , 100	,15),
		Player("d" , 100	,10),
		Player("e" , 100	,20),
	};
	Monster monster("monsterA", 100 , 15);	
	Zone	zone;

	zone.Admitted(monster);	
	zone.Attack(monster, 10 , 10);
	return 0;
}

